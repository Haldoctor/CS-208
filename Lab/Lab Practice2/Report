# Lab2 Practice Report
12312109 李泓霖
## Problem 1
### Main Thought
In the main algorithm, I used several built-in library functions in java to meet the need of matching the name and there index. And after that, the program just use the index to calculate the matching problem which have a significant efficiency improvement compared to just solve the problem by using the original name.
### Original code
```Java
import java.util.*;

public class StableMatching {
    public static void main(String[] args) {
        //Timing counter
        long startTime = System.currentTimeMillis();
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();

        //Boys name list
        String[] boys = new String[n];
        for (int i = 0; i < n; i++) {
            boys[i] = scanner.next();
        }

        //Girls name list
        String[] girls = new String[n];
        for (int i = 0; i < n; i++) {
            girls[i] = scanner.next();
        }

        //Boys preference list
        String[][] blike = new String[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                blike[i][j] = scanner.next();
            }
        }

        //Girls prefernce list
        String[][] glike = new String[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                glike[i][j] = scanner.next();
            }
        }

        //Store the boy name into a map
        Map<String, Integer> boy = new HashMap<>();
        for (int i = 0; i < n; i++) {
            boy.put(boys[i], i);
        }

        //Store the girl name into a map
        Map<String, Integer> girl = new HashMap<>();
        for (int i = 0; i < n; i++) {
            girl.put(girls[i], i);
        }

        //Store the girl's preference list into a map
        List<Map<String, Integer>> girlpre = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            Map<String, Integer> preference = new HashMap<>();
            for (int j = 0; j < n; j++) {
                preference.put(glike[i][j], j);
            }
            girlpre.add(preference);
        }

        //Store the single boys into a queue
        Queue<Integer> single = new LinkedList<>();

        //Store the index of girls that boys will try to match next
        int[] next = new int[n];
        Arrays.fill(next, 0);
        for (int i = 0; i < n; i++) {
            single.add(i);
        }

        //Create an array to store the girls current husband
        String[] husband = new String[n];

        //Main program circulation
        while (!single.isEmpty()) {
            int man = single.poll();
            String boyname = boys[man];
            int target = next[man];
            next[man]++;
            String targetGirl = blike[man][target];
            int girlidx = girl.get(targetGirl);
            String current = husband[girlidx];
            //If the girl doesn't have a husband
            if (current == null) {
                husband[girlidx] = boyname;
            }
            //If the girl has a husband, then compared the new boy with the current husband
            else {
                Map<String, Integer> pre = girlpre.get(girlidx);
                int curpos = pre.get(current);
                int newpos = pre.get(boyname);
                //If the new boy priority is higher than the current husband
                if (newpos < curpos) {
                    int exhus = boy.get(current);
                    single.add(exhus);
                    husband[girlidx] = boyname;
                }
                //If the new boy priority is less than the current husband
                else {
                    single.add(man);
                }
            }
        }
        //Restore the order of the data
        Map<String, String> result = new HashMap<>();
        for (int i = 0; i < n; i++) {
            result.put(husband[i], girls[i]);
        }
        //Output the result
        for (String boyName : boys) {
            System.out.println(boyName + " " + result.get(boyName));
        }
        //The end of the timing counter
        long endTime = System.currentTimeMillis();
        //Output the running time
        System.out.println("运行耗时: " + (endTime - startTime) + "ms");
    }
}
```
### Time counter
I use several lines of code to count the running time of the program. These lines of codes were generated by Deepseek. The result of running time includes the time of input and output, and the result's unit is 'ms'.

```Java
//Timing counter
long startTime = System.currentTimeMillis();
/*
Practice original code
*/
//End of timing counter
long endTime = System.currentTimeMillis();
System.out.println("运行耗时: " + (endTime - startTime) + "ms");
```
## Problem 2
### Minimum Input(N = 1)
```Java
//Input
1
b1
g1
b1 g1
g1 b1
//Output
b1 g1
```
### Simple Input(N = 3)
```Java
//Input
3
A B C
a b c
b a c
b a c
b c a
C B A
B C A
A C B
//Output
A a
B b
C c
```
### Edge Cases(All boys like one girl)
```Java
//Input
3
b1 b2 b3
g1 g2 g3
g1 g2 g3
g1 g2 g3
g1 g2 g3
b3 b2 b1
b1 b2 b3
b1 b2 b3
//Output
b1 g2
b2 g3
b3 g1
```
### Multiple Stable Solutions
In this section, the testcase has multiple outputs, as for the testcase below, my program always output the first version answer.
```Java
//Input
2
b1 b2
g1 g2
g1 g2
g2 g1
b2 b1
b1 b2
//Output
b1 g1
b2 g2
//Or there is another possible version of the output
b1 g2
b2 g1
```
### Conflict Scenarios
In this section, we test a testcase which is cyclic preference.
```Java
//Input
3
b1 b2 b3
g1 g2 g3
g1 g2 g3
g2 g3 g1
g3 g1 g2
b2 b3 b1
b3 b1 b2
b1 b2 b3
//Output
b1 g1
b2 g2
b3 g3
```
### Performance & Scalability(N >= 1000)
In this section, the test example is very large to test the efficiency of the program. I generate testcases by another java program. And in this large testcase, boys are from b1 ~ b1000, girls are from g1 ~ g1000. And the testcases generated by the program are totally random. An already generated testcases is stored in a ``` .txt ``` file in the folder.
Mention：When testing large testcases, please use "Indirect input from" function.
```Java
import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;

public class TestCaseGenerator {

    public static void main(String[] args) throws IOException {
        int N = 1000; // 可修改为任意规模
        boolean isExtremeCase = false; // true=极端场景 false=随机场景
        generateInputFile(N, isExtremeCase);
    }

    private static void generateInputFile(int N, boolean isExtremeCase) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter("performance_test_input.txt"))) {
            // 1. 写入N
            writer.write(String.valueOf(N));
            writer.newLine();

            // 2. 生成男孩和女孩名字
            List<String> boys = generateNames("b", N);
            List<String> girls = generateNames("g", N);

            // 3. 写入男孩列表
            writer.write(String.join(" ", boys));
            writer.newLine();

            // 4. 写入女孩列表
            writer.write(String.join(" ", girls));
            writer.newLine();

            // 5. 生成男孩偏好列表
            for (String boy : boys) {
                List<String> prefs;
                if (isExtremeCase) {
                    prefs = new ArrayList<>(girls); // 男孩按升序
                } else {
                    prefs = shuffledCopy(girls); // 随机偏好
                }
                writer.write(String.join(" ", prefs));
                writer.newLine();
            }

            // 6. 生成女孩偏好列表
            for (String girl : girls) {
                List<String> prefs;
                if (isExtremeCase) {
                    prefs = reversedCopy(boys); // 女孩按降序
                } else {
                    prefs = shuffledCopy(boys); // 随机偏好
                }
                writer.write(String.join(" ", prefs));
                writer.newLine();
            }
        }
    }

    private static List<String> generateNames(String prefix, int n) {
        List<String> names = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            names.add(prefix + i);
        }
        return names;
    }

    private static List<String> reversedCopy(List<String> list) {
        List<String> copy = new ArrayList<>(list);
        Collections.reverse(copy);
        return copy;
    }

    private static List<String> shuffledCopy(List<String> list) {
        List<String> copy = new ArrayList<>(list);
        Collections.shuffle(copy, new Random(System.currentTimeMillis()));
        return copy;
    }
}
```
The java code above is the program used to generate testcases. The newly generated testcase will just stores in the same direction where the code located.
Here are some results of the time consuming of different size testcases
| N | Time Consuming |
|:---------:|:-------:|
| 100 | 41ms |
| 500 | 222ms |
| 1000 | 631ms |
| 2000 | 1896ms |
| 5000 | 10121ms |
### Random-Scale & Distribution Tests
This section is same as the "Performance &  Scalability" section. The code in the previous section just generate the random testcases.
## Problem 3
### Manual Verification
In this section I will manual verification a testcase which its size is N = 2.
```Java
//Input
2
b1 b2
g1 g2
g1 g2
g2 g1
b1 b2
b2 b1
//Output
b1 g1
b2 g2
```
In this testcase, there is no better pairs which can replace pair (b1 , g1) and (b2 , g2), so the output is stable. And as this program boys take the initiative, so the results meet the boys preference first.
### Diff-Based Testing

## Problem 4
The results are different between boys propose first and girls propose first. Because in the algorithm, who takes the initiative who gets the better result.
